<link rel="import" href="../polymer/polymer.html"> 

<!--

A component for crossfiltering data using square crossfilter library

##### Example

    <th-data-crossfilter></th-data-crossfilter>

@element th-data-crossfilter
@blurb Element providing solution to no problem in particular.
@status alpha
@homepage http://thelmanews.github.io/th-data-crossfilter
-->

<polymer-element name="th-data-crossfilter" attributes="input output">
  <template>
    <link rel="stylesheet" href="th-data-crossfilter.css">
    <template repeat="{{attr in _dataAttributes}}">
      {{attr}}
      <div class="chart" id="data-{{attr}}">
      </div>
    </template>

  </template>
  <script src="../d3/d3.min.js"></script> <!--TODO: ? use d3-import.html? -->
  <script src="lib/crossfilter.js"></script> 
  <script>
    Polymer({
      input: [
        {a: 7, b: 2, c: 12, d: 5},
        {a: 4, b: 1, c: 14, d: 6},
        {a: 3, b: 2, c: 13, d: 7},
        {a: 1, b: 3, c: 13, d: 8},
        {a: 3, b: 0, c: 14, d: 9},
        {a: 8, b: 2, c: 20, d: 10},
        {a: 1, b: 2, c: 10, d: 11},
        {a: 2, b: 2, c: 15, d: 12},
        {a: 5, b: 3, c: 18, d: 13},
        {a: 2, b: 2, c: 15, d: 14},
        {a: 3, b: 1, c: 12, d: 15},
        {a: 9, b: 2, c: 20, d: 16}
        ],

      ready: function () {
        this.inputChanged();
            


      },

      
      inputChanged: function() {

          var self = this;
          var firstItem = self.input[0];
          if(!firstItem) {
            return;
          }
          var attributes = Object.keys(firstItem);
          
          if(JSON.stringify(self._dataAttributes) === JSON.stringify(attributes) ) {
            //self._mapChartData();
          }
          else {
            self._dataAttributes = attributes;
          }

          //self._findNumericalColumns();

          //self._calculateOutput(); 
          //
        //intitial output to pass input (filter nothing)
        this.output = this.input;

        this.crossfilter = crossfilter(this.input);
        this.groupAll = this.crossfilter.groupAll();

        //this.output = this.groups.all();
                   

        this._dimensions = [];
        this._charts = [];

        this._dataAttributes.forEach(function(attr) {
            var dimension = {};

            var n = this.input[0][attr];


            dimension.dim = this.crossfilter.dimension(function(d) {return d[attr]});
            dimension.group = dimension.dim.group();
            dimension.min = d3.min(this.input, function(d) {return d[attr] });
            dimension.max = d3.max(this.input, function(d) { return d[attr] });
            


            console.log('domain',dimension.group.top(Infinity));

            if(!isNaN(parseFloat(n)) && isFinite(n))
            {
              dimension.chart = barChart()
                .dimension(dimension.dim)
                .group(dimension.group)
                .x(d3.scale.linear()
                .domain([dimension.min, dimension.max])
                .rangeRound([0, 10 * 24]));
            }
            else {
              var domain = dimension.group.top(Infinity).map(function(item) {return item.key} );
              console.log('domain', domain);

              dimension.chart = barChart()
                .dimension(dimension.dim)
                .group(dimension.group)
                .x(d3.scale.ordinal()
                .domain(domain)
                .rangeRoundPoints([0, 10 * 24]));

                console.log(dimension.chart.x().range());

            }

            this._dimensions.push(dimension);
            this._charts.push(dimension.chart);

             
        }.bind(this));


        var chart;


        setTimeout(function() {

        var chartDivs = this.shadowRoot.querySelectorAll('.chart');



        chart = d3.selectAll(chartDivs)
              .data(this._charts)
              .each(function(chart) { chart.on("brush", renderAll).on("brushend", renderAll); });  

        chart.each(render);      


        }.bind(this),100);


       function render(method) {
          d3.select(this).call(method);
        }

         function renderAll() {
            chart.each(render);
        }        






        function barChart() {
            if (!barChart.id) barChart.id = 0;


            var margin = {top: 10, right: 10, bottom: 20, left: 10},
                x,
                y = d3.scale.linear().range([100, 0]),
                id = barChart.id++,
                axis = d3.svg.axis().orient("bottom"),
                brush = d3.svg.brush(),
                brushDirty,
                dimension,
                group,
                round;


            function chart(div) {

              console.log('range',x.range());
              var range = x.range(),
                  width = range[range.length-1],
                  height = y.range()[0];

              

              y.domain([0, group.top(1)[0].value]);

              div.each(function() {
                var div = d3.select(this),
                    g = div.select("g");

                // Create the skeletal chart.
                if (g.empty()) {
                  div.select(".title").append("a")
                      .attr("href", "javascript:reset(" + id + ")")
                      .attr("class", "reset")
                      .text("reset")
                      .style("display", "none");

                  g = div.append("svg")
                      .attr("width", width + margin.left + margin.right)
                      .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                      .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

                  g.append("clipPath")
                      .attr("id", "clip-" + id)
                    .append("rect")
                      .attr("width", width)
                      .attr("height", height);


                  g.selectAll(".bar")
                      .data(["background", "foreground"])
                    .enter().append("path")
                      .attr("class", function(d) { return d + " bar"; })
                      .datum(group.all());

                  g.selectAll(".foreground.bar")
                      .attr("clip-path", "url(#clip-" + id + ")");

                  g.append("g")
                      .attr("class", "axis")
                      .attr("transform", "translate(0," + height + ")")
                      .call(axis);

                  // Initialize the brush component with pretty resize handles.
                  var gBrush = g.append("g").attr("class", "brush").call(brush);
                  gBrush.selectAll("rect").attr("height", height);
                  gBrush.selectAll(".resize").append("path").attr("d", resizePath);
                }

                // Only redraw the brush if set externally.
                if (brushDirty) {
                  brushDirty = false;
                  g.selectAll(".brush").call(brush);
                  div.select(".title a").style("display", brush.empty() ? "none" : null);
                  if (brush.empty()) {
                    g.selectAll("#clip-" + id + " rect")
                        .attr("x", 0)
                        .attr("width", width);
                  } else {
                    var extent = brush.extent();
                    g.selectAll("#clip-" + id + " rect")
                        .attr("x", x(extent[0]))
                        .attr("width", x(extent[1]) - x(extent[0]));
                  }
                }

                g.selectAll(".bar").attr("d", barPath);
              });

              function barPath(groups) {
                var path = [],
                    i = -1,
                    n = groups.length,
                    d;
                while (++i < n) {
                  d = groups[i];
                  path.push("M", x(d.key), ",", height, "V", y(d.value), "h9V", height);
                }
                return path.join("");
              }

              function resizePath(d) {
                var e = +(d == "e"),
                    x = e ? 1 : -1,
                    y = height / 3;
                return "M" + (.5 * x) + "," + y
                    + "A6,6 0 0 " + e + " " + (6.5 * x) + "," + (y + 6)
                    + "V" + (2 * y - 6)
                    + "A6,6 0 0 " + e + " " + (.5 * x) + "," + (2 * y)
                    + "Z"
                    + "M" + (2.5 * x) + "," + (y + 8)
                    + "V" + (2 * y - 8)
                    + "M" + (4.5 * x) + "," + (y + 8)
                    + "V" + (2 * y - 8);
              }
            }
            //end chart

            brush.on("brushstart.chart", function() {
              var div = d3.select(this.parentNode.parentNode.parentNode);
              div.select(".title a").style("display", null);
            });

            brush.on("brush.chart", function() {
              var g = d3.select(this.parentNode),
                  extent = brush.extent();
              if (round) g.select(".brush")
                  .call(brush.extent(extent = extent.map(round)))
                .selectAll(".resize")
                  .style("display", null);
              g.select("#clip-" + id + " rect")
                  .attr("x", x(extent[0]))
                  .attr("width", x(extent[1]) - x(extent[0]));
              dimension.filterRange(extent);
              self.output = dimension.top(Infinity);
            });

            brush.on("brushend.chart", function() {
              if (brush.empty()) {
                var div = d3.select(this.parentNode.parentNode.parentNode);
                div.select(".title a").style("display", "none");
                div.select("#clip-" + id + " rect").attr("x", null).attr("width", "100%");
                dimension.filterAll();
                self.output = self.input;
              }
            });

            chart.margin = function(_) {
              if (!arguments.length) return margin;
              margin = _;
              return chart;
            };

            chart.x = function(_) {
              if (!arguments.length) return x;
              x = _;
              axis.scale(x);
              brush.x(x);
              return chart;
            };

            chart.y = function(_) {
              if (!arguments.length) return y;
              y = _;
              return chart;
            };

            chart.dimension = function(_) {
              if (!arguments.length) return dimension;
              dimension = _;
              return chart;
            };

            chart.filter = function(_) {
              if (_) {
                brush.extent(_);
                dimension.filterRange(_);
              } else {
                brush.clear();
                dimension.filterAll();
              }
              brushDirty = true;
              return chart;
            };

            chart.group = function(_) {
              if (!arguments.length) return group;
              group = _;
              return chart;
            };

            chart.round = function(_) {
              if (!arguments.length) return round;
              round = _;
              return chart;
            };

            return d3.rebind(chart, brush, "on");

          }
          //barchart?

      },       
    });
  </script>
</polymer-element>